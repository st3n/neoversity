# Видача Решти

## Опис завдання

Ми маємо набір монет [50, 25, 10, 5, 2, 1]. Потрібно розробити систему для касового апарату, яка визначає оптимальний спосіб видачі решти покупцеві.

## Функції

1. **Жадібний алгоритм**
    - `find_coins_greedy(amount)`
    - Використовує жадібний підхід для визначення мінімальної кількості монет для видачі заданої суми.
    - Часова складність: O(n)
    - Просторова складність: O(1)

2. **Алгоритм динамічного програмування**
    - `find_min_coins(amount)`
    - Використовує метод динамічного програмування для визначення мінімальної кількості монет для видачі заданої суми.
    - Часова складність: O(n * m)
    - Просторова складність: O(m)

## Результати тесту

Testing with amount: 127
Greedy algorithm result: {50: 2, 25: 1, 2: 1}, time: 0.000023 seconds
DP algorithm result: {2: 1, 25: 1, 50: 2}, time: 0.002237 seconds

Testing with amount: 549
Greedy algorithm result: {50: 10, 25: 1, 10: 2, 2: 2}, time: 0.000031 seconds
DP algorithm result: {2: 2, 10: 2, 25: 1, 50: 10}, time: 0.011557 seconds

Testing with amount: 1168
Greedy algorithm result: {50: 23, 10: 1, 5: 1, 2: 1, 1: 1}, time: 0.000036 seconds
DP algorithm result: {1: 1, 2: 1, 5: 1, 10: 1, 50: 23}, time: 0.025957 seconds

Testing with amount: 5440
Greedy algorithm result: {50: 108, 25: 1, 10: 1, 5: 1}, time: 0.000028 seconds
DP algorithm result: {5: 1, 10: 1, 25: 1, 50: 108}, time: 0.124050 seconds

Testing with amount: 16851
Greedy algorithm result: {50: 337, 1: 1}, time: 0.000024 seconds
DP algorithm result: {1: 1, 50: 337}, time: 0.402761 seconds

Testing with amount: 55555
Greedy algorithm result: {50: 1111, 5: 1}, time: 0.000022 seconds
DP algorithm result: {5: 1, 50: 1111}, time: 1.378193 seconds

Testing with amount: 196196
Greedy algorithm result: {50: 3923, 25: 1, 10: 2, 1: 1}, time: 0.000033 seconds
DP algorithm result: {1: 1, 10: 2, 25: 1, 50: 3923}, time: 5.172231 seconds


## Порівняння ефективності

- **Жадібний алгоритм** швидший та простіший у реалізації, але може не давати оптимального рішення для нестандартних наборів монет.
- **Алгоритм динамічного програмування** завжди знаходить оптимальне рішення, але є повільнішим та складнішим у реалізації.

## Висновок

Для стандартного набору монет варто використовувати жадібний алгоритм через його швидкість та простоту. Однак, якщо потрібна гарантія оптимального рішення для будь-якого набору монет, слід використовувати алгоритм динамічного програмування.
